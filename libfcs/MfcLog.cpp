/*
 * Copyright (c) 2013-2021 MFCXY, Inc. <mfcxy@mfcxy.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*

 How to use this class:

 ILog (ILog.h) is a virtual interface for logging that MfcLog conforms to.
 MfcLog (MfcLog.h/MfcLog.cpp) implements ILog.
 Log (Log.h/Log.cpp) implements a static/global class wrapping MfcLog (not thread safe)

 About ILog:

 Log lines generated by consumers of Log will fall into three different
 classes: main, debug, or trace.  Main logs are ones usually always written to disk or
 syslogged.  debug and trace logs usually are off in production environments, but can
 be turned on in runtime to start debugging (medium volume) or tracing (high volume)
 output from the Log consumer program.

 Logs must have a level (ILog::LogLevel) which mirrors syslog() levels (LOG_EMERG...LOG_DEBUG).
 The only mismatch is Log class renames syslog's LOG_INFO to DEBUG, and renames syslog's
 LOG_DEBUG to TRACE.

 Log level ILog::TRACE (syslog's LOG_DEBUG) is part of the trace class, ILog::DBG (syslog's
 LOG_INFO) is part of the debug class, and all other log levels are part of the main class.
 The class a log level is in dictates which file (if file output is turned on) a log is
 written to.

 By default, Log routes output to both STDOUT and a log file.  Optionally, logs of
 various level can be routed to syslog and stderr as well. ILog::LogData.nOutputMasks[]
 dictates which log levels go to which output methods.  For example, setting
 LogData.nOutputMasks[ILog::DBG] |= ILog::OF_STDERR will make DEBUG log items be sent
 (in addition to any other bit modes set in the output mask) STDERR.

 To set filenames for where log classes are written to, set ILog::LogData.sLogFiles[ILog::LogClass]
 The default names are based on the program's binary filename, i.e:
 a.out.log, dbg_a.out.log, and trace_a.out.log.

 To set location where log files are written, set ILog::LogData.sLogDir.  The default
 location is /tmp.

 Header information included in the log output (pid, timestamp) are options
 set by setting bit values on ILog::LogData.nStampMask.

 To make log files automatically rotate, set ILog::LogData.nAutoRotateSz to a non-zero
 value.  Prior to each log file write, if the file is larger than nAutoRotateSz
 it will be deleted and recreated.

 See testLog.cpp for more examples.


 Updates for the future:

 1) Optional file locking so that multiple processes can write to the same files without jumbling.
    This would require the log be truncated rather than unlinked, otherwise other processes would
    be still writing to the old inode until they decided to rotate.
 2) Warn to stdout if file open fails?
 3) If write() call in in _Mesg() fails, consider closing/reopening the file.
 4) Optional SIGHUP handler function that closes/reopens all log files?
 5) Pretty printing certain data? I.e. hex representations of non printable data, etc.

*/

#ifndef _WIN32
#include <sys/time.h>
#include <arpa/inet.h>
#include <syslog.h>
#include <unistd.h>
#include <execinfo.h>
#include <dlfcn.h>
#else
#include <winsock2.h>
#include <windows.h>
#include <io.h>
#include <process.h>
#include <psapi.h>
#endif

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <time.h>
#include <errno.h>

#include <string>
#include <iostream>
#include <algorithm>
#include <memory>
#include <vector>
#include <set>

#include <libPlugins/Portable.h>

#include "Compat.h"
#include "fcslib_string.h"
#include "MfcLog.h"
#include "UtilCommon.h"
#include "MfcTimer.h"

extern char *__progname;
char g_dummyCharVal = 'x';


void MfcLog::Setup(const string& sLogDir)
{
    m_Data.fTraceFunction       = true;

    for (size_t n = 0; n < ILog::MAX_LOGLEVEL; n++)
        m_Data.nOutputMasks[n] = OF_STDOUT | OF_FILE;

    m_Data.nStampMask           = (ILog::TS_MONTHDAY | ILog::TS_HOURMIN | ILog::TS_SEC | ILog::TS_MSEC);
    m_Data.nAutoRotateSz        = 0;
    m_Data.nAutoRotateTm        = 0;

    m_Data.sLogDir = sLogDir.empty() ? "/tmp" : sLogDir;

    for (size_t n = 0; n < ILog::MAX_LOGCLASS; n++)
    {
        m_Data.nLogFds[n] = -1;
        m_Data.tvLastOpen[n].tv_sec = 0;
        m_Data.tvLastOpen[n].tv_usec = 0;
    }

    SetLog(ILog::MAX_LOGCLASS, NULL, false);
}


void MfcLog::SetLog(LogClass nClass, const char* pszFile, bool fUnlink)
{
    const char* pch;

    if (nClass < ILog::MAX_LOGCLASS)
    {
        // Don't let filename have path references, move to end of path reference (if there is one)
        if ((pch = strrchr(pszFile, '/')))
            pch++;
        else
            pch = pszFile;

        m_Data.sLogFiles[nClass] = pch;

        if (m_Data.nLogFds[nClass] > -1)
        {
#ifdef _WIN32
            _close(m_Data.nLogFds[nClass]);
#else
            close(m_Data.nLogFds[nClass]);
#endif
            m_Data.nLogFds[nClass] = -1;
            m_Data.tvLastOpen[nClass].tv_sec = 0;
            m_Data.tvLastOpen[nClass].tv_usec = 0;
        }

        if (fUnlink)
#ifdef _WIN32
            _unlink(stdprintf("%s/%s", m_Data.sLogDir.c_str(), m_Data.sLogFiles[nClass].c_str()).c_str());
#else
            unlink(stdprintf("%s/%s", m_Data.sLogDir.c_str(), m_Data.sLogFiles[nClass].c_str()).c_str());
#endif
    }
    else
    {
        stdprintf(m_Data.sLogFiles[LC_MAIN],  "%s.log",     __progname);
        stdprintf(m_Data.sLogFiles[LC_DEBUG], "dbg_%s",     m_Data.sLogFiles[LC_MAIN].c_str());
        stdprintf(m_Data.sLogFiles[LC_TRACE], "trace_%s",   m_Data.sLogFiles[LC_MAIN].c_str());
    }
}


bool MfcLog::GetLog(LogClass nClass, string& sFile)
{
    bool fRet = false;

    if (nClass < ILog::MAX_LOGCLASS)
    {
        sFile = stdprintf("%s/%s", m_Data.sLogDir.c_str(), m_Data.sLogFiles[nClass].c_str());
        fRet = true;
    }

    return fRet;
}


size_t MfcLog::DeleteLogs(LogClass nClass)
{
    size_t nRemoved = 0;

    for (size_t n = 0; n < MAX_LOGCLASS; n++)
        if (nClass == static_cast< LogClass >(n) || nClass == MAX_LOGCLASS)
#ifdef _WIN32
            if (_unlink( stdprintf("%s/%s", m_Data.sLogDir.c_str(), m_Data.sLogFiles[n].c_str()).c_str()) == 0)
#else
            if (unlink( stdprintf("%s/%s", m_Data.sLogDir.c_str(), m_Data.sLogFiles[n].c_str()).c_str()) == 0)
#endif
                nRemoved++;

    return nRemoved;
}


void MfcLog::Mesg(const char* pszFmt, ...)
{
    char szData[8192];
    va_list vaList;

    va_start(vaList, pszFmt);
#ifdef _WIN32
    _vsnprintf_s(szData, sizeof(szData), _TRUNCATE, pszFmt, vaList);
#else
    vsnprintf(szData, sizeof(szData), pszFmt, vaList);
#endif
    va_end(vaList);

    _Mesg(ILog::NOTICE, szData);
}


void MfcLog::Debug(const char* pszFmt, ...)
{
    char szData[8192];
    va_list vaList;

    va_start(vaList, pszFmt);
#ifdef _WIN32
    _vsnprintf_s(szData, sizeof(szData), _TRUNCATE, pszFmt, vaList);
#else
    vsnprintf(szData, sizeof(szData), pszFmt, vaList);
#endif
    va_end(vaList);

    _Mesg(ILog::DBG, szData);
}


void MfcLog::Trace(const char* pszFmt, ...)
{
    char szData[8192];
    va_list vaList;

    va_start(vaList, pszFmt);
#ifdef _WIN32
    _vsnprintf_s(szData, sizeof(szData), _TRUNCATE, pszFmt, vaList);
#else
    vsnprintf(szData, sizeof(szData), pszFmt, vaList);
#endif
    va_end(vaList);

    _Mesg(ILog::TRACE, szData);
}


void MfcLog::Mesg(LogLevel nLevel, const char* pszFmt, ...)
{
    char szData[8192];
    va_list vaList;

    va_start(vaList, pszFmt);
#ifdef _WIN32
    _vsnprintf_s(szData, sizeof(szData), _TRUNCATE, pszFmt, vaList);
#else
    vsnprintf(szData, sizeof(szData), pszFmt, vaList);
#endif
    va_end(vaList);

    _Mesg(nLevel, szData);
}


void MfcLog::TraceMarker(const char* pszFile, const char* pszFunction, int nLine, LogLevel nLevel, const char* pszFmt, ...)
{
    char szData[8192];
    char* pszTraceFmt = (char*)"(%s:%d) ";           // Trace header defaults to just file:line
    va_list vaList;

    // Optionally support inclusion of function in trace header
    if (m_Data.fTraceFunction)
        pszTraceFmt = (char*)"%s:%d %s(): ";

    int nLen = snprintf(szData, sizeof(szData), pszTraceFmt, pszFile, nLine, pszFunction);

    // An error or truncated header? then we drop the tracefmt header by writing the remaining log data to szData+0
    if (nLen < 0 || nLen > (int)sizeof(szData))
        nLen = 0;

    va_start(vaList, pszFmt);
#ifdef _WIN32
    _vsnprintf_s(szData + nLen, sizeof(szData) - nLen, _TRUNCATE, pszFmt, vaList);
#else
    vsnprintf(szData + nLen, sizeof(szData) - nLen, pszFmt, vaList);
#endif
    va_end(vaList);

    _Mesg(nLevel, szData);
}


void MfcLog::_Mesg(LogLevel nLevel, const char* pszMesg)
{
    char szModuleName[MAX_PATH] = { '\0' };
    struct timeval tvNow;
    char szTmp[512];
    struct tm tmNow;
    struct stat st;
    char* pszFmt;
    string sLog;
    int n;

    gettimeofday(&tvNow, NULL);

#ifdef _INCLUDE_MODULE_NAME_
#ifdef _WIN32
    _localtime32_s(&tmNow, (__time32_t*)&tvNow.tv_sec);

    //GetModuleFileNameExA(GetCurrentProcess(), GetModuleHandle(NULL), szModuleName, sizeof(szModuleName));
    HMODULE phModule = NULL;
    if ( GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
        (LPCSTR) &g_dummyCharVal,
        &phModule) )
    {
        char szFile[MAX_PATH];
        GetModuleFileNameA(phModule, szFile, sizeof(szFile));
        char* pch = strrchr(szFile, '\\');
        if (pch)
            fcs_strlcpy(szModuleName, pch + 1, sizeof(szModuleName));
        else fcs_strlcpy(szModuleName, szFile, sizeof(szModuleName));
    }
    else fcs_strlcpy(szModuleName, "error-getting-module-handle", sizeof(szModuleName));
#else
    struct tm* pCt = localtime(&tvNow.tv_sec);
    if (pCt)
        tmNow = *pCt;
    else
        memset(&tmNow, 0, sizeof(tmNow));

    char szModuleName[256];

    Dl_info dylib;
    if (dladdr(&g_dummyCharVal, &dylib) != 0)
    {
        const char* pch = strrchr(dylib.dli_fname, '/');
        if (pch)
            fcs_strlcpy(szModuleName, pch + 1, sizeof(szModuleName));
        else fcs_strlcpy(szModuleName, dylib.dli_fname, sizeof(szModuleName));
    }
    else fcs_strlcpy(szModuleName, "module-err", sizeof(szModuleName));
#endif
#endif

    // Hardcode the most common time formats as an optimization (less calls to snprintf)
    if (m_Data.nStampMask == (ILog::TS_YEAR | ILog::TS_MONTHDAY | ILog::TS_HOURMIN | ILog::TS_SEC))
    {
        stdprintf(  sLog,
                    "[%s%04d-%02d-%02d %02d:%02d:%02d] ",
                    szModuleName,
                    1900 + tmNow.tm_year, tmNow.tm_mon + 1, tmNow.tm_mday,
                    tmNow.tm_hour, tmNow.tm_min, tmNow.tm_sec);
    }
    else if (m_Data.nStampMask == (ILog::TS_MONTHDAY | ILog::TS_HOURMIN | ILog::TS_SEC | ILog::TS_MSEC))
    {
        stdprintf(  sLog,
                    "[%s%02d-%02d %02d:%02d:%02d.%04d] ",
                    szModuleName,
                    tmNow.tm_mon + 1, tmNow.tm_mday,
                    tmNow.tm_hour, tmNow.tm_min, tmNow.tm_sec,
                    tvNow.tv_usec / 1000);
    }
    else if (m_Data.nStampMask == (ILog::TS_PID | ILog::TS_MONTHDAY | ILog::TS_HOURMIN | ILog::TS_SEC | ILog::TS_MSEC))
    {
        stdprintf(  sLog,
                    "[%d %02d-%02d %02d:%02d:%02d.%04d] ",
                    szModuleName,
#ifdef _WIN32
                    _getpid(),
#else
                    getpid(),
#endif
                    tmNow.tm_mon + 1, tmNow.tm_mday,
                    tmNow.tm_hour, tmNow.tm_min, tmNow.tm_sec,
                    tvNow.tv_usec / 1000);
    }
    else if (m_Data.nStampMask == (ILog::TS_PROGNAME | ILog::TS_PID | ILog::TS_YEAR | ILog::TS_MONTHDAY | ILog::TS_HOURMIN | ILog::TS_SEC))
    {
        stdprintf(  sLog,
                    "[%s%s:%d %04d-%02d-%02d %02d:%02d:%02d] ",
                    szModuleName,
                    __progname,
#ifdef _WIN32
                    _getpid(),
#else
                    getpid(),
#endif
                    1900 + tmNow.tm_year, tmNow.tm_mon + 1, tmNow.tm_mday,
                    tmNow.tm_hour, tmNow.tm_min, tmNow.tm_sec);
    }

    // Build timestamp string piece-meal
    else
    {
        sLog = "[";

        sLog += szModuleName;
        //sLog += " ";

        if (m_Data.nStampMask & ILog::TS_PROGNAME)
            sLog += __progname;

        if (m_Data.nStampMask & ILog::TS_PID)
        {
            // Prefix ":" if we have progname already as part of timestamp log, so
            // log will look like '[FCWorker:23891 2015-03-19 13:45:11]' if
            // progname and pid are both included
#ifdef _WIN32
            sLog += stdprintf("%s%05d", sLog.length() > 1 ? ":" : "", _getpid());
#else
            sLog += stdprintf("%s%05d", sLog.length() > 1 ? ":" : "", getpid());
#endif
        }

        if (m_Data.nStampMask & ILog::TS_MONTHDAY)
        {
            // prepend space if existing string
            if (sLog.length() > 1)
                sLog += " ";

            // Possible formats are YYYY-MM-DD and MM-DD

            if (m_Data.nStampMask & ILog::TS_YEAR)
                snprintf(szTmp, sizeof(szTmp), "%04d-%02d-%02d", 1900 + tmNow.tm_year, tmNow.tm_mon+1, tmNow.tm_mday);
            else
                snprintf(szTmp, sizeof(szTmp), "%02d-%02d", tmNow.tm_mon+1, tmNow.tm_mday);

            sLog += szTmp;
        }

        if (m_Data.nStampMask & ILog::TS_HOURMIN)
        {
            // prepend space if existing string
            if (sLog.length() > 1)
                sLog += " ";

            // Possible formats are HH:MM:SS.ssss, HH:MM:SS, and HH:MM

            if (m_Data.nStampMask & ILog::TS_SEC)
            {
                if (m_Data.nStampMask & ILog::TS_MSEC)  pszFmt = (char*)"%02d:%02d:%02d.%04d";
                else pszFmt = (char*)"%02d:%02d:%02d";
            }
            else pszFmt = (char*)"%02d:%02d";

            snprintf(szTmp, sizeof(szTmp), pszFmt, tmNow.tm_hour, tmNow.tm_min, tmNow.tm_sec, tvNow.tv_usec / 1000);
            sLog += szTmp;
        }

        if (sLog.length() > 1)
            sLog += "] ";
        else
            sLog.clear();
    }

    sLog += pszMesg;

/*  // Reimplement option to strip ansi colors from logs that don't go to stdout or stderr
    string sNewLog;
    sNewLog.reserve(sLog.size());
    bool escape = false;

    // Strip ANSI Colors from other log formats
    for (size_t n = 0; n < sLog.size(); n++)
    {
        if (n + 3 < sLog.size()     &&
            sLog.at(n+0) == '\x1b'  &&
            sLog.at(n+1) == '['     )
            escape = true;
        else if (escape && sLog.at(n) == 'm')
            escape = false;
        else if (!escape) sNewLog += sLog.at(n);
    }
    sLog = sNewLog;*/

#ifndef _WIN32
    // Output syslog prior to \n concat
    if (m_Data.nOutputMasks[nLevel] & OF_SYSLOG)
        syslog((int)nLevel, "%s", sLog.c_str());
#else
    //if (m_Data.nOutputMasks[nLevel] & OF_DEBUGGER)
    //   OutputDebugStringA(stdprintf("%s\r\n", sLog.c_str()).c_str());

    if (m_Data.nOutputMasks[nLevel] & OF_HWND)
    {
        //OutputConsoleString(stdprintf("%s\r\n", sLog.c_str()));
    }
#endif

    sLog += "\n";

    if (m_Data.nOutputMasks[nLevel] & OF_FILE)
    {
        // If auto-rotate file is on and its been >5 seconds since we last checked,
        // check each LogClass file to see if it needs to be deleted
        if (m_Data.nAutoRotateSz > 0 && tvNow.tv_sec - m_Data.nAutoRotateTm > 5)
        {
            for (size_t n = 0; n < ILog::MAX_LOGCLASS; n++)
            {
                snprintf(szTmp, sizeof(szTmp), "%s/%s", m_Data.sLogDir.c_str(), m_Data.sLogFiles[n].c_str());
                if (stat(szTmp, &st) == 0)
                {
                    if ((size_t)st.st_size > m_Data.nAutoRotateSz)
                    {
                        // Close handle if its open before unlink
                        if (m_Data.nLogFds[n] > -1)
                        {
#ifdef _WIN32
                            _close(m_Data.nLogFds[n]);
#else
                            close(m_Data.nLogFds[n]);
#endif
                            m_Data.nLogFds[n] = -1;
                            m_Data.tvLastOpen[n].tv_sec = 0;
                            m_Data.tvLastOpen[n].tv_usec = 0;
                        }
#ifdef _WIN32
                        _unlink(szTmp);
#else
                        unlink(szTmp);
#endif
                    }
                }
            }

            m_Data.nAutoRotateTm = tvNow.tv_sec;
        }

        // If we've been open for >3sec, close/reopen to make sure deleted log files get detected and re-opened correctly
        if (MfcTimer::DiffTime(tvNow, m_Data.tvLastOpen[ClassOf(nLevel)]) >= 3.0)
        {
            if (m_Data.nLogFds[ClassOf(nLevel)] > -1)
            {
#ifdef _WIN32
                _close(m_Data.nLogFds[ClassOf(nLevel)]);
#else
                close(m_Data.nLogFds[ClassOf(nLevel)]);
#endif
                m_Data.nLogFds[ClassOf(nLevel)] = -1;
                m_Data.tvLastOpen[ClassOf(nLevel)].tv_sec = 0;
                m_Data.tvLastOpen[ClassOf(nLevel)].tv_usec = 0;
            }
        }

        // find file handle to write to
        if (m_Data.nLogFds[ClassOf(nLevel)] == -1)
            OpenLog(ClassOf(nLevel));

        if (m_Data.nLogFds[ClassOf(nLevel)] > -1)
        {
#ifdef _WIN32
            if ((n = _write(m_Data.nLogFds[ClassOf(nLevel)], sLog.c_str(), sLog.size())) != (int)sLog.size())
#else
            if ((n = write(m_Data.nLogFds[ClassOf(nLevel)], sLog.c_str(), sLog.size())) != (int)sLog.size())
#endif
            {
                // Error writing to file? try close/open the file
                if (n == -1)
                {
#ifdef _WIN32
                    _close(m_Data.nLogFds[ClassOf(nLevel)]);
#else
                    close(m_Data.nLogFds[ClassOf(nLevel)]);
#endif
                    m_Data.nLogFds[ClassOf(nLevel)] = -1;
                    m_Data.tvLastOpen[ClassOf(nLevel)].tv_sec = 0;
                    m_Data.tvLastOpen[ClassOf(nLevel)].tv_usec = 0;

                    OpenLog(ClassOf(nLevel));

                    if (m_Data.nLogFds[ClassOf(nLevel)] > -1)
#ifdef _WIN32
                        _write(m_Data.nLogFds[ClassOf(nLevel)], sLog.c_str(), sLog.size());
#else
                        write(m_Data.nLogFds[ClassOf(nLevel)], sLog.c_str(), sLog.size());
#endif
                }
            }
        }
    }

    //if (m_Data.nOutputMasks[nLevel] & OF_STDOUT)
    //    fwrite(sLog.c_str(), sLog.length(), 1, stdout);
#ifdef _WIN32
    if (m_Data.nOutputMasks[nLevel] & OF_STDERR)
        fwrite(sLog.c_str(), sLog.length(), 1, stderr);
#endif
}


bool MfcLog::OpenLog(LogClass nClass)
{
    bool fOpened = false;
    char szBuf[512];

    if (m_Data.nLogFds[nClass] > -1)
    {
#ifdef _WIN32
        _close(m_Data.nLogFds[nClass]);
#else
        close(m_Data.nLogFds[nClass]);
#endif
        m_Data.nLogFds[nClass] = -1;
        m_Data.tvLastOpen[nClass].tv_sec = 0;
        m_Data.tvLastOpen[nClass].tv_usec = 0;
    }

    if (m_Data.sLogFiles[nClass].size() > 0)
    {
        snprintf(szBuf, sizeof(szBuf), "%s/%s", m_Data.sLogDir.c_str(), m_Data.sLogFiles[nClass].c_str());
#ifndef _WIN32
        if ((m_Data.nLogFds[nClass] = open(szBuf, O_WRONLY | O_APPEND | O_CREAT, S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP | S_IWOTH | S_IROTH)) != -1)
#else
        if (_sopen_s(&m_Data.nLogFds[nClass], szBuf, _O_WRONLY | _O_APPEND | _O_BINARY | _O_CREAT, _SH_DENYNO, _S_IREAD | _S_IWRITE) == 0)
#endif
        {
            fOpened = true;
            gettimeofday(&m_Data.tvLastOpen[nClass], NULL);
        }
    }

    return fOpened;
}


void MfcLog::SetStampMask(int nValue)
{
    m_Data.nStampMask = nValue;
}


void MfcLog::AddStampMask(int nValue)
{
    m_Data.nStampMask |= nValue;
}


void MfcLog::SetAutoRotate(size_t nSz)
{
    m_Data.nAutoRotateSz = nSz;
    m_Data.nAutoRotateTm = 0;
}


void MfcLog::SetOutputMask(ILog::LogLevel nLevel, int nValue)
{
    if (nLevel < ILog::MAX_LOGLEVEL)
        m_Data.nOutputMasks[nLevel] = nValue;
}


void MfcLog::AddOutputMask(ILog::LogLevel nLevel, int nValue)
{
    if (nLevel < ILog::MAX_LOGLEVEL)
        m_Data.nOutputMasks[nLevel] |= nValue;
}


void MfcLog::SubOutputMask(ILog::LogLevel nLevel, int nValue)
{
    if (nLevel < ILog::MAX_LOGLEVEL && m_Data.nOutputMasks[nLevel] & nValue)
        m_Data.nOutputMasks[nLevel] ^= nValue;
}


bool MfcLog::HasOutputMask(ILog::LogLevel nLevel, int nValue)
{
    return (nLevel < ILog::MAX_LOGLEVEL && m_Data.nOutputMasks[nLevel] & nValue);
}


int MfcLog::GetOutputMask(ILog::LogLevel nLevel)
{
    return nLevel < ILog::MAX_LOGLEVEL ? m_Data.nOutputMasks[nLevel] : 0;
}


void MfcLog::Flush(void)
{
    for (int n = 0; n < ILog::MAX_LOGCLASS; n++)
    {
        if (m_Data.nLogFds[n] > -1)
        {
#ifdef _WIN32
            _close(m_Data.nLogFds[n]);
#else
            close(m_Data.nLogFds[n]);
#endif
            m_Data.nLogFds[n] = -1;
            m_Data.tvLastOpen[n].tv_sec = 0;
            m_Data.tvLastOpen[n].tv_usec = 0;
        }
    }
}
